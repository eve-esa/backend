{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#eve-backend","title":"EVE Backend","text":"<p>A FastAPI-based backend service for chat with Retrieval-Augmented Generation (RAG). It provides authentication, collections and document ingestion, conversation/message management, streaming responses, and a hallucination detection pipeline. Documentation is generated via MkDocs + mkdocstrings.</p> <p>For setup, Docker usage, local development, and deployment details, refer to README.md.</p>"},{"location":"#architecture","title":"Architecture","text":"<ul> <li>FastAPI: HTTP API and dependency injection</li> <li>MongoDB/DocumentDB: Primary datastore for users, collections, documents, conversations, messages</li> <li>Qdrant: Vector store for embeddings and retrieval</li> <li>LLM providers: Pluggable via <code>src/core/llm_manager.py</code></li> <li>Docs: MkDocs Material + mkdocstrings (Sphinx-style docstrings)</li> </ul>"},{"location":"#directory-structure","title":"Directory structure","text":"<pre><code>src/\n  routers/            # FastAPI route handlers (auth, collection, document, conversation, message, tool, user, health)\n  services/           # Business logic (auth, generate_answer, email, hallucination, etc.)\n  database/           # ODM-style models and pagination helpers\n  core/               # Vector store and LLM managers\n  middlewares/        # Authentication dependencies\n  schemas/            # Pydantic request/response models\n  templates/          # Prompt templates and pipeline configs\n  utils/              # Helpers, parsers, embeddings, rerankers\ntests/                # API and domain tests\ndocs/                 # Site content (this page, api references)\n</code></pre>"},{"location":"#key-workflows","title":"Key workflows","text":"<ul> <li>Authentication</li> <li>Signup, email activation, login, refresh</li> <li>Endpoints in <code>routers.auth</code> and <code>routers.forgot_password</code></li> <li>Collections &amp; Documents</li> <li>Create Qdrant collections, upload documents, delete documents</li> <li>Ingestion triggers parsing, chunking, embedding, and vector upsert</li> <li>Endpoints in <code>routers.collection</code> and <code>routers.document</code></li> <li>Conversations &amp; Messages</li> <li>Create conversations, post messages, stream responses (SSE)</li> <li>Retry message generation, update feedback/annotations</li> <li>Endpoints in <code>routers.conversation</code> and <code>routers.message</code></li> <li>Hallucination Detection</li> <li>Synchronous detection and streaming modes</li> <li>Annotates message metadata with label, reason, timings</li> </ul>"},{"location":"#api-surface-reference","title":"API surface (reference)","text":"<ul> <li>Auth: <code>[routers-auth]</code> \u2014 <code>routers.auth</code></li> <li>Collections: <code>[routers-collection]</code> \u2014 <code>routers.collection</code></li> <li>Documents: <code>[routers-document]</code> \u2014 <code>routers.document</code></li> <li>Conversations: <code>[routers-conversation]</code> \u2014 <code>routers.conversation</code></li> <li>Messages: <code>[routers-message]</code> \u2014 <code>routers.message</code></li> <li>Users: <code>[routers-user]</code> \u2014 <code>routers.user</code></li> <li>Health: <code>[routers-health_check]</code> \u2014 <code>routers.health_check</code></li> </ul>"},{"location":"#message-generation-flow-high-level","title":"Message generation flow (high-level)","text":"<ol> <li>Validate conversation ownership and requested collections</li> <li>Expand requested collections with allowed public and user-owned collections</li> <li>Optionally extract year range from filters for MCP usage</li> <li>If starting a new chat, create <code>Conversation</code> first; then create placeholder <code>Message</code> record</li> <li>Run the answer generation pipeline:</li> <li>Build context (RAG decision, retrieval, reranking)</li> <li>Generate answer from LLM and record timings and prompt metadata</li> <li>Update <code>Message</code> output (answer), documents, flags, and latencies</li> <li>Optionally schedule rollup/trim in background</li> <li>For streaming endpoints, publish tokens and lifecycle events via bus</li> </ol>"},{"location":"#documentation-notes","title":"Documentation notes","text":"<ul> <li>Docstrings are Sphinx-style with <code>:param</code>, <code>:type</code>, <code>:return</code>, <code>:rtype</code>, <code>:raises</code>.</li> <li>Module reference pages in <code>docs/</code> use:</li> </ul> <pre><code>::: routers.&lt;module&gt;\nhandler: python\n</code></pre>"},{"location":"routers-auth/","title":"Auth","text":"<p>handler: python</p>"},{"location":"routers-auth/#routers.auth","title":"<code>auth</code>","text":""},{"location":"routers-auth/#routers.auth.login","title":"<code>login(request: LoginRequest) -&gt; LoginResponse</code>  <code>async</code>","text":"<p>Authenticate a user and issue JWT tokens.</p> <p>Validates the provided credentials, ensures the account is active, and returns an access and refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>LoginRequest</code> <p>Login credentials payload.</p> required <p>Returns:</p> Type Description <code>LoginResponse</code> <p>Access and refresh tokens.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>401 if invalid credentials or user not found; 403 if account not activated.</p> Source code in <code>src/routers/auth.py</code> <pre><code>@router.post(\"/login\", response_model=LoginResponse)\nasync def login(request: LoginRequest) -&gt; LoginResponse:\n    \"\"\"\n    Authenticate a user and issue JWT tokens.\n\n    Validates the provided credentials, ensures the account is active, and returns an access and refresh token.\n\n    Args:\n        request (LoginRequest): Login credentials payload.\n\n    Returns:\n        Access and refresh tokens.\n\n    Raises:\n        HTTPException: 401 if invalid credentials or user not found; 403 if account not activated.\n    \"\"\"\n    if not await verify_user(request.email, request.password):\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n\n    user = await User.find_one({\"email\": request.email})\n    if not user:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n    if not user.is_active:\n        raise HTTPException(\n            status_code=403, detail=\"Account not activated. Please check your email.\"\n        )\n\n    return LoginResponse(\n        access_token=create_access_token(sub=user.id),\n        refresh_token=create_refresh_token(sub=user.id),\n    )\n</code></pre>"},{"location":"routers-auth/#routers.auth.refresh","title":"<code>refresh(request: RefreshRequest) -&gt; RefreshResponse</code>  <code>async</code>","text":"<p>Exchange a refresh token for a new access token.</p> <p>Decodes and validates the provided refresh token and returns a new access token if the token and user are valid.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>RefreshRequest</code> <p>Refresh token payload.</p> required <p>Returns:</p> Type Description <code>RefreshResponse</code> <p>Fresh access token.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>401 if invalid refresh token or user not found.</p> Source code in <code>src/routers/auth.py</code> <pre><code>@router.post(\"/refresh\", response_model=RefreshResponse)\nasync def refresh(request: RefreshRequest) -&gt; RefreshResponse:\n    \"\"\"\n    Exchange a refresh token for a new access token.\n\n    Decodes and validates the provided refresh token and returns a new access token if the token and user are valid.\n\n    Args:\n        request (RefreshRequest): Refresh token payload.\n\n    Returns:\n        Fresh access token.\n\n    Raises:\n        HTTPException: 401 if invalid refresh token or user not found.\n    \"\"\"\n    try:\n        payload = jwt.decode(\n            request.refresh_token,\n            JWT_SECRET_KEY,\n            algorithms=[JWT_ALGORITHM],\n            audience=JWT_AUDIENCE_REFRESH,\n        )\n        user_id = payload.get(\"sub\")\n        if not user_id:\n            raise HTTPException(status_code=401, detail=\"Invalid refresh token\")\n\n        # Use find_by_id instead of find_one with _id\n        user = await User.find_by_id(user_id)\n        if not user:\n            raise HTTPException(status_code=401, detail=\"User not found\")\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid refresh token\")\n\n    return RefreshResponse(\n        access_token=create_access_token(sub=user.id),\n    )\n</code></pre>"},{"location":"routers-auth/#routers.auth.signup","title":"<code>signup(request: SignupRequest) -&gt; SignupResponse</code>  <code>async</code>","text":"<p>Register a new user and send an activation email.</p> <p>Creates a user account and emails an activation link containing a one-time activation code.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>SignupRequest</code> <p>Signup payload with user details and password.</p> required <p>Returns:</p> Type Description <code>SignupResponse</code> <p>Created user summary.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>400 if invalid or duplicate signup data.</p> Source code in <code>src/routers/auth.py</code> <pre><code>@router.post(\"/signup\", response_model=SignupResponse)\nasync def signup(request: SignupRequest) -&gt; SignupResponse:\n    \"\"\"\n    Register a new user and send an activation email.\n\n    Creates a user account and emails an activation link containing a one-time activation code.\n\n    Args:\n        request (SignupRequest): Signup payload with user details and password.\n\n    Returns:\n        Created user summary.\n\n    Raises:\n        HTTPException: 400 if invalid or duplicate signup data.\n    \"\"\"\n    try:\n        user = await create_user(\n            email=request.email,\n            password=request.password,\n            first_name=request.first_name,\n            last_name=request.last_name,\n        )\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    verification_url = (\n        f\"{FRONTEND_URL}/verify?email={user.email}&amp;code={user.activation_code}\"\n    )\n    email_service.send_email(\n        to_email=user.email,\n        subject=\"Activate your EVE account\",\n        template_name=\"activation.html\",\n        context={\n            \"verification_url\": verification_url,\n        },\n    )\n    return SignupResponse(\n        id=user.id,\n        email=user.email,\n        first_name=user.first_name,\n        last_name=user.last_name,\n    )\n</code></pre>"},{"location":"routers-auth/#routers.auth.resend_activation","title":"<code>resend_activation(request: ResendActivationRequest) -&gt; dict</code>  <code>async</code>","text":"<p>Resend the account activation email.</p> <p>Generates a new activation code (if the account is not yet active) and sends the activation email again.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ResendActivationRequest</code> <p>Email address for the account.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if user is not found.</p> Source code in <code>src/routers/auth.py</code> <pre><code>@router.post(\"/resend-activation\")\nasync def resend_activation(request: ResendActivationRequest) -&gt; dict:\n    \"\"\"\n    Resend the account activation email.\n\n    Generates a new activation code (if the account is not yet active) and sends the activation email again.\n\n    Args:\n        request (ResendActivationRequest): Email address for the account.\n\n    Returns:\n        Confirmation message.\n\n    Raises:\n        HTTPException: 404 if user is not found.\n    \"\"\"\n    user = await User.find_one({\"email\": request.email})\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    if user.is_active:\n        return {\"message\": \"Account already activated.\"}\n    user.activation_code = generate_activation_code()\n    await user.save()\n    verification_url = (\n        f\"{FRONTEND_URL}/verify?email={user.email}&amp;code={user.activation_code}\"\n    )\n    email_service.send_email(\n        to_email=user.email,\n        subject=\"Activate your EVE account\",\n        template_name=\"activation.html\",\n        context={\n            \"verification_url\": verification_url,\n        },\n    )\n    return {\"message\": \"Activation code resent.\"}\n</code></pre>"},{"location":"routers-auth/#routers.auth.verify","title":"<code>verify(request: VerifyRequest) -&gt; dict</code>  <code>async</code>","text":"<p>Verify account activation using the activation code.</p> <p>Marks the user as active if the provided code matches and clears the code.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>VerifyRequest</code> <p>Verification payload with email and activation code.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if user not found; 400 if activation code is invalid.</p> Source code in <code>src/routers/auth.py</code> <pre><code>@router.post(\"/verify\")\nasync def verify(request: VerifyRequest) -&gt; dict:\n    \"\"\"\n    Verify account activation using the activation code.\n\n    Marks the user as active if the provided code matches and clears the code.\n\n    Args:\n        request (VerifyRequest): Verification payload with email and activation code.\n\n    Returns:\n        Confirmation message.\n\n    Raises:\n        HTTPException: 404 if user not found; 400 if activation code is invalid.\n    \"\"\"\n    user = await User.find_one({\"email\": request.email})\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    if user.is_active:\n        return {\"message\": \"Account already activated.\"}\n    if user.activation_code != request.activation_code:\n        raise HTTPException(status_code=400, detail=\"Invalid activation code\")\n    user.is_active = True\n    user.activation_code = None\n    await user.save()\n    return {\"message\": \"Account activated successfully.\"}\n</code></pre>"},{"location":"routers-collection/","title":"Collection","text":""},{"location":"routers-collection/#routers.collection","title":"<code>collection</code>","text":""},{"location":"routers-collection/#routers.collection.list_public_collections","title":"<code>list_public_collections(pagination: Pagination = Depends()) -&gt; PaginatedResponse[Collection]</code>  <code>async</code>","text":"<p>List public collections with pagination.</p> <p>Combines platform-curated public collections and environment-specific public collections, then paginates the combined list.</p> <p>Parameters:</p> Name Type Description Default <code>pagination</code> <code>Pagination</code> <p>Pagination parameters.</p> <code>Depends()</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Collection]</code> <p>Paginated list of public collections.</p> Source code in <code>src/routers/collection.py</code> <pre><code>@router.get(\"/collections/public\", response_model=PaginatedResponse[Collection])\nasync def list_public_collections(pagination: Pagination = Depends()) -&gt; PaginatedResponse[Collection]:\n    \"\"\"\n    List public collections with pagination.\n\n    Combines platform-curated public collections and environment-specific public collections, then paginates the combined list.\n\n    Args:\n        pagination (Pagination): Pagination parameters.\n\n    Returns:\n        Paginated list of public collections.\n    \"\"\"\n    public_collections, total_count = await vector_store.list_public_collections(\n        page=pagination.page, limit=pagination.limit\n    )\n\n    if IS_PROD:\n        public_collections = WILEY_PUBLIC_COLLECTIONS + public_collections\n    else:\n        public_collections = WILEY_PUBLIC_COLLECTIONS + STAGING_PUBLIC_COLLECTIONS\n    total_count = len(public_collections)\n    # Pagination must be done manually since Qdrant doesn't support collection pagination\n    return PaginatedResponse(\n        data=[\n            Collection(\n                id=collection[\"name\"],\n                name=collection.get(\"alias\") or collection[\"name\"],\n                description=collection[\"description\"],\n                user_id=None,\n                embeddings_model=DEFAULT_EMBEDDING_MODEL,\n            )\n            for collection in public_collections\n        ],\n        meta=get_pagination_metadata(total_count, pagination.page, pagination.limit),\n    )\n</code></pre>"},{"location":"routers-collection/#routers.collection.list_collections","title":"<code>list_collections(request: Pagination = Depends(), request_user: User = Depends(get_current_user)) -&gt; PaginatedResponse[Collection]</code>  <code>async</code>","text":"<p>List collections owned by the current user.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Pagination</code> <p>Pagination parameters.</p> <code>Depends()</code> <code>request_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Collection]</code> <p>Paginated list of user collections.</p> Source code in <code>src/routers/collection.py</code> <pre><code>@router.get(\"/collections\", response_model=PaginatedResponse[Collection])\nasync def list_collections(\n    request: Pagination = Depends(), request_user: User = Depends(get_current_user)\n) -&gt; PaginatedResponse[Collection]:\n    \"\"\"\n    List collections owned by the current user.\n\n    Args:\n        request (Pagination): Pagination parameters.\n        request_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Paginated list of user collections.\n    \"\"\"\n    return await Collection.find_all_with_pagination(\n        limit=request.limit,\n        page=request.page,\n        filter_dict={\"user_id\": request_user.id},\n        sort=[(\"timestamp\", -1)],\n    )\n</code></pre>"},{"location":"routers-collection/#routers.collection.get_collection","title":"<code>get_collection(collection_id: str) -&gt; dict</code>  <code>async</code>","text":"<p>Get a collection by id with document and vector counts.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>Target collection identifier.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Collection data including documents_count and points_count.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if collection is not found.</p> Source code in <code>src/routers/collection.py</code> <pre><code>@router.get(\"/collections/{collection_id}\")\nasync def get_collection(collection_id: str) -&gt; dict:\n    \"\"\"\n    Get a collection by id with document and vector counts.\n\n    Args:\n        collection_id (str): Target collection identifier.\n\n    Returns:\n        Collection data including documents_count and points_count.\n\n    Raises:\n        HTTPException: 404 if collection is not found.\n    \"\"\"\n    collection = await Collection.find_by_id(collection_id)\n    if not collection:\n        raise HTTPException(status_code=404, detail=\"Collection not found\")\n\n    documents_count, points_count = await _get_counts_for_id(collection_id)\n\n    return {\n        **collection.dict(),\n        \"documents_count\": documents_count,\n        \"points_count\": points_count,\n    }\n</code></pre>"},{"location":"routers-collection/#routers.collection.create_collection","title":"<code>create_collection(request: CollectionRequest, requesting_user: User = Depends(get_current_user)) -&gt; Collection</code>  <code>async</code>","text":"<p>Create a private collection and provision its backing vector index (Qdrant).</p> <p>The new collection is private to its creator. The MongoDB collection ID is used as the Qdrant collection name.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>CollectionRequest</code> <p>New collection parameters.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>Collection</code> <p>Created collection.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>500 if vector collection creation fails or on server errors.</p> Source code in <code>src/routers/collection.py</code> <pre><code>@router.post(\"/collections\", response_model=Collection)\nasync def create_collection(\n    request: CollectionRequest,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; Collection:\n    \"\"\"\n    Create a private collection and provision its backing vector index (Qdrant).\n\n    The new collection is private to its creator. The MongoDB collection ID is used as the Qdrant collection name.\n\n    Args:\n        request (CollectionRequest): New collection parameters.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Created collection.\n\n    Raises:\n        HTTPException: 500 if vector collection creation fails or on server errors.\n    \"\"\"\n    collection = Collection(\n        name=request.name,\n        user_id=requesting_user.id,\n        description=request.description,\n        embeddings_model=request.embeddings_model,\n    )\n    await collection.save()\n\n    try:\n        VectorStoreManager(embeddings_model=request.embeddings_model).create_collection(\n            collection.id\n        )\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        logger.warning(\n            f\"Warning: failed to create Qdrant collection {collection.id}: {e}\"\n        )\n        await collection.delete()\n        raise HTTPException(\n            status_code=500,\n            detail=f\"Failed to create vector collection: {str(e)}\",\n        )\n\n    return collection\n</code></pre>"},{"location":"routers-collection/#routers.collection.update_collection","title":"<code>update_collection(request: CollectionUpdate, collection_id: str, requesting_user: User = Depends(get_current_user)) -&gt; Collection</code>  <code>async</code>","text":"<p>Update a collection's mutable fields.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>CollectionUpdate</code> <p>Update payload (e.g., name).</p> required <code>collection_id</code> <code>str</code> <p>Collection identifier.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>Collection</code> <p>Updated collection.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 403 if update is forbidden; 500 for server errors.</p> Source code in <code>src/routers/collection.py</code> <pre><code>@router.patch(\"/collections/{collection_id}\")\nasync def update_collection(\n    request: CollectionUpdate,\n    collection_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; Collection:\n    \"\"\"\n    Update a collection's mutable fields.\n\n    Args:\n        request (CollectionUpdate): Update payload (e.g., name).\n        collection_id (str): Collection identifier.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Updated collection.\n\n    Raises:\n        HTTPException: 404 if not found; 403 if update is forbidden; 500 for server errors.\n    \"\"\"\n    try:\n        collection = await Collection.find_by_id(collection_id)\n        if not collection:\n            raise HTTPException(status_code=404, detail=\"Collection not found\")\n\n        if collection.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to update this collection\",\n            )\n\n        collection.name = request.name\n        updated_collection = await collection.save()\n        return updated_collection\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-collection/#routers.collection.delete_collection","title":"<code>delete_collection(collection_id: str, requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Delete a collection and its related resources.</p> <p>Deletes documents in the collection, attempts to remove the vector index, and finally deletes the collection record.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>Collection identifier.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 403 if deletion is forbidden; 500 for server errors.</p> Source code in <code>src/routers/collection.py</code> <pre><code>@router.delete(\"/collections/{collection_id}\")\nasync def delete_collection(\n    collection_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Delete a collection and its related resources.\n\n    Deletes documents in the collection, attempts to remove the vector index, and finally deletes the collection record.\n\n    Args:\n        collection_id (str): Collection identifier.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Confirmation message.\n\n    Raises:\n        HTTPException: 404 if not found; 403 if deletion is forbidden; 500 for server errors.\n    \"\"\"\n    try:\n        collection = await Collection.find_by_id(collection_id)\n        if not collection:\n            raise HTTPException(status_code=404, detail=\"Collection not found\")\n        if collection.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to delete this collection\",\n            )\n\n        await Document.delete_many({\"collection_id\": collection_id})\n\n        try:\n            await anyio.to_thread.run_sync(\n                vector_store.delete_collection, collection_id\n            )\n        except Exception as e:\n            logger.warning(\n                f\"Warning: failed to delete Qdrant collection {collection_id}: {e}\"\n            )\n\n        await collection.delete()\n        return {\"message\": \"Collection deleted successfully\"}\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-conversation/","title":"Conversation","text":""},{"location":"routers-conversation/#routers.conversation","title":"<code>conversation</code>","text":""},{"location":"routers-conversation/#routers.conversation.list_conversations","title":"<code>list_conversations(request_user: User = Depends(get_current_user), pagination: Pagination = Depends()) -&gt; PaginatedResponse[Conversation]</code>  <code>async</code>","text":"<p>List conversations owned by the current user.</p> <p>Parameters:</p> Name Type Description Default <code>request_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <code>pagination</code> <code>Pagination</code> <p>Pagination parameters.</p> <code>Depends()</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Conversation]</code> <p>Paginated conversations for the user.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>500 for server errors.</p> Source code in <code>src/routers/conversation.py</code> <pre><code>@router.get(\"/conversations\", response_model=PaginatedResponse[Conversation])\nasync def list_conversations(\n    request_user: User = Depends(get_current_user), pagination: Pagination = Depends()\n) -&gt; PaginatedResponse[Conversation]:\n    \"\"\"\n    List conversations owned by the current user.\n\n    Args:\n        request_user (User): Authenticated user injected by dependency.\n        pagination (Pagination): Pagination parameters.\n\n    Returns:\n        Paginated conversations for the user.\n\n    Raises:\n        HTTPException: 500 for server errors.\n    \"\"\"\n    try:\n        result = await Conversation.find_all_with_pagination(\n            filter_dict={\"user_id\": request_user.id},\n            page=pagination.page,\n            limit=pagination.limit,\n            sort=[(\"timestamp\", -1)],\n        )\n\n        return result\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-conversation/#routers.conversation.get_conversation","title":"<code>get_conversation(conversation_id: str, requesting_user: User = Depends(get_current_user)) -&gt; ConversationDetail</code>  <code>async</code>","text":"<p>Get a conversation and its messages.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>ConversationDetail</code> <p>Conversation with messages and metadata.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 403 if access is forbidden; 500 for server errors.</p> Source code in <code>src/routers/conversation.py</code> <pre><code>@router.get(\"/conversations/{conversation_id}\", response_model=ConversationDetail)\nasync def get_conversation(\n    conversation_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; ConversationDetail:\n    \"\"\"\n    Get a conversation and its messages.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Conversation with messages and metadata.\n\n    Raises:\n        HTTPException: 404 if not found; 403 if access is forbidden; 500 for server errors.\n    \"\"\"\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to get this conversation\",\n            )\n\n        # Fetch messages for this conversation\n        messages = await Message.find_all(\n            filter_dict={\"conversation_id\": conversation_id}, sort=[(\"timestamp\", 1)]\n        )\n\n        return ConversationDetail(\n            id=conversation.id,\n            user_id=conversation.user_id,\n            name=conversation.name,\n            timestamp=conversation.timestamp,\n            messages=messages,\n        )\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-conversation/#routers.conversation.create_conversation","title":"<code>create_conversation(request: ConversationCreate, requesting_user: User = Depends(get_current_user)) -&gt; Conversation</code>  <code>async</code>","text":"<p>Create a new conversation for the current user.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ConversationCreate</code> <p>New conversation payload.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>Conversation</code> <p>Created conversation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>500 for server errors.</p> Source code in <code>src/routers/conversation.py</code> <pre><code>@router.post(\"/conversations\", response_model=Conversation)\nasync def create_conversation(\n    request: ConversationCreate,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; Conversation:\n    \"\"\"\n    Create a new conversation for the current user.\n\n    Args:\n        request (ConversationCreate): New conversation payload.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Created conversation.\n\n    Raises:\n        HTTPException: 500 for server errors.\n    \"\"\"\n    try:\n        return await Conversation.create(\n            user_id=requesting_user.id,\n            name=request.name,\n        )\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-conversation/#routers.conversation.update_conversation_name","title":"<code>update_conversation_name(conversation_id: str, request: ConversationNameUpdate, requesting_user: User = Depends(get_current_user)) -&gt; Conversation</code>  <code>async</code>","text":"<p>Update a conversation's name.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>request</code> <code>ConversationNameUpdate</code> <p>New name payload.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>Conversation</code> <p>Updated conversation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 403 if update is forbidden; 500 for server errors.</p> Source code in <code>src/routers/conversation.py</code> <pre><code>@router.patch(\"/conversations/{conversation_id}\")\nasync def update_conversation_name(\n    conversation_id: str,\n    request: ConversationNameUpdate,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; Conversation:\n    \"\"\"\n    Update a conversation's name.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        request (ConversationNameUpdate): New name payload.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Updated conversation.\n\n    Raises:\n        HTTPException: 404 if not found; 403 if update is forbidden; 500 for server errors.\n    \"\"\"\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to update this conversation\",\n            )\n\n        conversation.name = request.name\n        await conversation.save()\n\n        return conversation\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-conversation/#routers.conversation.delete_conversation","title":"<code>delete_conversation(conversation_id: str, requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Delete a conversation and its messages.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 403 if deletion is forbidden; 500 for server errors.</p> Source code in <code>src/routers/conversation.py</code> <pre><code>@router.delete(\"/conversations/{conversation_id}\")\nasync def delete_conversation(\n    conversation_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Delete a conversation and its messages.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Confirmation message.\n\n    Raises:\n        HTTPException: 404 if not found; 403 if deletion is forbidden; 500 for server errors.\n    \"\"\"\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to delete this conversation\",\n            )\n\n        await Message.delete_many({\"conversation_id\": conversation_id})\n        await conversation.delete()\n        return {\"message\": \"Conversation deleted successfully\"}\n\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-document/","title":"Document","text":""},{"location":"routers-document/#routers.document","title":"<code>document</code>","text":"<p>RESTful document endpoints for collections.</p>"},{"location":"routers-document/#routers.document.get_collection_and_validate_ownership","title":"<code>get_collection_and_validate_ownership(collection_id: str, requesting_user: User) -&gt; Collection</code>  <code>async</code>","text":"<p>Get collection and validate user ownership.</p> Source code in <code>src/routers/document.py</code> <pre><code>async def get_collection_and_validate_ownership(\n    collection_id: str, requesting_user: User\n) -&gt; Collection:\n    \"\"\"Get collection and validate user ownership.\"\"\"\n    collection = await Collection.find_by_id(collection_id)\n    if not collection:\n        raise HTTPException(status_code=404, detail=\"Collection not found\")\n\n    if collection.user_id != requesting_user.id:\n        raise HTTPException(\n            status_code=403, detail=\"You are not allowed to access this collection\"\n        )\n\n    return collection\n</code></pre>"},{"location":"routers-document/#routers.document.list_documents","title":"<code>list_documents(collection_id: str = Path(..., description='Collection ID'), pagination: Pagination = Depends(), requesting_user: User = Depends(get_current_user)) -&gt; PaginatedResponse[DocumentModel]</code>  <code>async</code>","text":"<p>List documents in a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>Collection identifier.</p> <code>Path(..., description='Collection ID')</code> <code>pagination</code> <code>Pagination</code> <p>Pagination parameters.</p> <code>Depends()</code> <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>PaginatedResponse[Document]</code> <p>Paginated documents for the collection.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if collection is not found; 403 if access is forbidden.</p> Source code in <code>src/routers/document.py</code> <pre><code>@router.get(\n    \"/collections/{collection_id}/documents\",\n    response_model=PaginatedResponse[DocumentModel],\n)\nasync def list_documents(\n    collection_id: str = Path(..., description=\"Collection ID\"),\n    pagination: Pagination = Depends(),\n    requesting_user: User = Depends(get_current_user),\n) -&gt; PaginatedResponse[DocumentModel]:\n    \"\"\"\n    List documents in a collection.\n\n    Args:\n        collection_id (str): Collection identifier.\n        pagination (Pagination): Pagination parameters.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Paginated documents for the collection.\n\n    Raises:\n        HTTPException: 404 if collection is not found; 403 if access is forbidden.\n    \"\"\"\n    await get_collection_and_validate_ownership(collection_id, requesting_user)\n\n    return await DocumentModel.find_all_with_pagination(\n        filter_dict={\"collection_id\": collection_id},\n        limit=pagination.limit,\n        page=pagination.page,\n        sort=[(\"timestamp\", -1)],\n    )\n</code></pre>"},{"location":"routers-document/#routers.document.get_document","title":"<code>get_document(collection_id: str = Path(..., description='Collection ID'), document_id: str = Path(..., description='Document ID'), requesting_user: User = Depends(get_current_user)) -&gt; DocumentModel</code>  <code>async</code>","text":"<p>Get a specific document from a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>Collection identifier.</p> <code>Path(..., description='Collection ID')</code> <code>document_id</code> <code>str</code> <p>Document identifier.</p> <code>Path(..., description='Document ID')</code> <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>Document</code> <p>Document details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 400 if document not in collection; 403 if access is forbidden.</p> Source code in <code>src/routers/document.py</code> <pre><code>@router.get(\n    \"/collections/{collection_id}/documents/{document_id}\", response_model=DocumentModel\n)\nasync def get_document(\n    collection_id: str = Path(..., description=\"Collection ID\"),\n    document_id: str = Path(..., description=\"Document ID\"),\n    requesting_user: User = Depends(get_current_user),\n) -&gt; DocumentModel:\n    \"\"\"\n    Get a specific document from a collection.\n\n    Args:\n        collection_id (str): Collection identifier.\n        document_id (str): Document identifier.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Document details.\n\n    Raises:\n        HTTPException: 404 if not found; 400 if document not in collection; 403 if access is forbidden.\n    \"\"\"\n    await get_collection_and_validate_ownership(collection_id, requesting_user)\n\n    document = await DocumentModel.find_by_id(document_id)\n    if not document:\n        raise HTTPException(status_code=404, detail=\"Document not found\")\n\n    if document.collection_id != collection_id:\n        raise HTTPException(\n            status_code=400, detail=\"Document does not belong to this collection\"\n        )\n\n    if document.user_id != requesting_user.id:\n        raise HTTPException(\n            status_code=403, detail=\"You are not allowed to access this document\"\n        )\n\n    return document\n</code></pre>"},{"location":"routers-document/#routers.document.upload_documents","title":"<code>upload_documents(collection_id: str = Path(..., description='Collection ID'), files: List[UploadFile] = File(...), metadata_urls: Optional[List[str] | str] = Form(default=None), metadata_names: Optional[List[str] | str] = Form(default=None), embeddings_model: str = Form(default=DEFAULT_EMBEDDING_MODEL), chunk_size: int = Form(default=DEFAULT_CHUNK_SIZE), chunk_overlap: int = Form(default=DEFAULT_CHUNK_OVERLAP), requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Upload documents to a collection.</p> <p>Stores document records and triggers asynchronous parsing, chunking, and vectorization for retrieval.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>Collection identifier.</p> <code>Path(..., description='Collection ID')</code> <code>files</code> <code>list[UploadFile]</code> <p>One or more files to ingest.</p> <code>File(...)</code> <code>metadata_urls</code> <code>list[str] | str | None</code> <p>Optional list or single URL per file.</p> <code>Form(default=None)</code> <code>metadata_names</code> <code>list[str] | str | None</code> <p>Optional list or single display name per file.</p> <code>Form(default=None)</code> <code>embeddings_model</code> <code>str</code> <p>Embeddings model to use for vectorization.</p> <code>Form(default=DEFAULT_EMBEDDING_MODEL)</code> <code>chunk_size</code> <code>int</code> <p>Chunk size for splitting documents.</p> <code>Form(default=DEFAULT_CHUNK_SIZE)</code> <code>chunk_overlap</code> <code>int</code> <p>Overlap between chunks.</p> <code>Form(default=DEFAULT_CHUNK_OVERLAP)</code> <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Service response with ingestion details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if collection is not found; 403 if access is forbidden; 500 for processing errors.</p> Source code in <code>src/routers/document.py</code> <pre><code>@router.post(\"/collections/{collection_id}/documents\")\nasync def upload_documents(\n    collection_id: str = Path(..., description=\"Collection ID\"),\n    files: List[UploadFile] = File(...),\n    metadata_urls: Optional[List[str] | str] = Form(default=None),\n    metadata_names: Optional[List[str] | str] = Form(default=None),\n    embeddings_model: str = Form(default=DEFAULT_EMBEDDING_MODEL),\n    chunk_size: int = Form(default=DEFAULT_CHUNK_SIZE),\n    chunk_overlap: int = Form(default=DEFAULT_CHUNK_OVERLAP),\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Upload documents to a collection.\n\n    Stores document records and triggers asynchronous parsing, chunking, and vectorization for retrieval.\n\n    Args:\n        collection_id (str): Collection identifier.\n        files (list[UploadFile]): One or more files to ingest.\n        metadata_urls (list[str] | str | None): Optional list or single URL per file.\n        metadata_names (list[str] | str | None): Optional list or single display name per file.\n        embeddings_model (str): Embeddings model to use for vectorization.\n        chunk_size (int): Chunk size for splitting documents.\n        chunk_overlap (int): Overlap between chunks.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Service response with ingestion details.\n\n    Raises:\n        HTTPException: 404 if collection is not found; 403 if access is forbidden; 500 for processing errors.\n    \"\"\"\n    collection = await get_collection_and_validate_ownership(\n        collection_id, requesting_user\n    )\n\n    logger.info(\n        f\"Received {len(files)} files for processing in collection {collection_id}\"\n    )\n\n    docs_data = [\n        DocumentModel(\n            user_id=requesting_user.id,\n            collection_id=collection_id,\n            name=file.filename,\n            filename=file.filename,\n            file_type=os.path.splitext(file.filename)[1].lstrip(\".\"),\n            source_url=metadata_urls[i] if metadata_urls else None,\n        )\n        for i, file in enumerate(files)\n    ]\n\n    try:\n        effective_model = collection.embeddings_model or embeddings_model\n        result = await document_service.add_documents(\n            collection_name=collection_id,\n            files=files,\n            request=AddDocumentRequest(\n                embeddings_model=effective_model,\n                chunk_size=chunk_size,\n                chunk_overlap=chunk_overlap,\n                metadata_urls=metadata_urls,\n                metadata_names=metadata_names,\n            ),\n            metadata_urls=metadata_urls,\n            metadata_names=metadata_names,\n        )\n\n        if not result.success:\n            raise HTTPException(status_code=500, detail=result.error)\n\n        await DocumentModel.bulk_create(docs_data)\n        return result.data\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        logger.error(f\"Error processing documents: {str(e)}\", exc_info=True)\n        raise HTTPException(\n            status_code=500, detail=f\"Error processing documents: {str(e)}\"\n        )\n</code></pre>"},{"location":"routers-document/#routers.document.delete_document","title":"<code>delete_document(collection_id: str = Path(..., description='Collection ID'), document_id: str = Path(..., description='Document ID'), requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Delete a document from a collection.</p> <p>Removes the document record and attempts to delete associated vectors.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>Collection identifier.</p> <code>Path(..., description='Collection ID')</code> <code>document_id</code> <code>str</code> <p>Document identifier.</p> <code>Path(..., description='Document ID')</code> <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if not found; 400 if document not in collection; 403 if deletion is forbidden.</p> Source code in <code>src/routers/document.py</code> <pre><code>@router.delete(\"/collections/{collection_id}/documents/{document_id}\")\nasync def delete_document(\n    collection_id: str = Path(..., description=\"Collection ID\"),\n    document_id: str = Path(..., description=\"Document ID\"),\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Delete a document from a collection.\n\n    Removes the document record and attempts to delete associated vectors.\n\n    Args:\n        collection_id (str): Collection identifier.\n        document_id (str): Document identifier.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Confirmation message.\n\n    Raises:\n        HTTPException: 404 if not found; 400 if document not in collection; 403 if deletion is forbidden.\n    \"\"\"\n    await get_collection_and_validate_ownership(collection_id, requesting_user)\n\n    document = await DocumentModel.find_by_id(document_id)\n    if not document:\n        raise HTTPException(status_code=404, detail=\"Document not found\")\n\n    if document.collection_id != collection_id:\n        raise HTTPException(\n            status_code=400, detail=\"Document does not belong to this collection\"\n        )\n\n    if document.user_id != requesting_user.id:\n        raise HTTPException(\n            status_code=403, detail=\"You are not allowed to delete this document\"\n        )\n\n    vector_store = VectorStoreManager()\n    try:\n        vector_store.delete_docs_by_metadata_filter(\n            collection_name=collection_id,\n            metadata={\"document_id\": document_id},\n        )\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        logger.error(f\"Failed to delete vectors for document {document_id}: {e}\")\n\n    await document.delete()\n    return {\"message\": \"Document and embeddings deleted successfully\"}\n</code></pre>"},{"location":"routers-forgot_password/","title":"Forgot Password","text":""},{"location":"routers-forgot_password/#routers.forgot_password","title":"<code>forgot_password</code>","text":""},{"location":"routers-forgot_password/#routers.forgot_password.send_forgot_password_code","title":"<code>send_forgot_password_code(request: ForgotPasswordRequest)</code>  <code>async</code>","text":"<p>Send a password reset code to the user's email.</p> <p>Generates a one-time code, stores it with an expiry, and emails a reset link.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ForgotPasswordRequest</code> <p>Request containing the user's email.</p> required <p>Returns:</p> Type Description <p>Dict[str, str]: Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if user not found.</p> Source code in <code>src/routers/forgot_password.py</code> <pre><code>@router.post(\"/code\", response_model=Dict[str, str])\nasync def send_forgot_password_code(request: ForgotPasswordRequest):\n    \"\"\"Send a password reset code to the user's email.\n\n    Generates a one-time code, stores it with an expiry, and emails a reset link.\n\n    Args:\n        request (ForgotPasswordRequest): Request containing the user's email.\n\n    Returns:\n        Dict[str, str]: Confirmation message.\n\n    Raises:\n        HTTPException: 404 if user not found.\n    \"\"\"\n    user = await User.find_one({\"email\": request.email})\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    code = \"\".join(random.choices(string.ascii_uppercase + string.digits, k=6))\n\n    already_exists = await ForgotPassword.find_one({\"email\": request.email})\n    if already_exists:\n        already_exists.code = code\n        already_exists.expires_at = datetime.now(timezone.utc) + timedelta(\n            minutes=FORGOT_PASSWORD_CODE_EXPIRE_MINUTES\n        )\n        await already_exists.save()\n\n    reset_url = f\"{FRONTEND_URL}/reset-password?code={code}\"\n    email_service.send_email(\n        to_email=request.email,\n        subject=\"Forgot Password\",\n        template_name=\"forgot_password.html\",\n        context={\n            \"reset_url\": reset_url,\n            \"expiry_minutes\": FORGOT_PASSWORD_CODE_EXPIRE_MINUTES,\n        },\n    )\n\n    await ForgotPassword.create(email=request.email, code=code)\n\n    return {\"message\": \"Code sent\"}\n</code></pre>"},{"location":"routers-forgot_password/#routers.forgot_password.confirm_new_password","title":"<code>confirm_new_password(request: ForgotPasswordConfirmation)</code>  <code>async</code>","text":"<p>Confirm a password reset with the provided code and new password.</p> <p>Validates the reset code and its expiry, ensures password confirmation matches, updates the user's password, and invalidates the code.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ForgotPasswordConfirmation</code> <p>Confirmation payload with code and new password.</p> required <p>Returns:</p> Type Description <p>Dict[str, str]: Confirmation message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if code is invalid or expired, or user not found.</p> <code>HTTPException</code> <p>400 if passwords do not match.</p> Source code in <code>src/routers/forgot_password.py</code> <pre><code>@router.post(\"/confirm\", response_model=Dict[str, str])\nasync def confirm_new_password(request: ForgotPasswordConfirmation):\n    \"\"\"Confirm a password reset with the provided code and new password.\n\n    Validates the reset code and its expiry, ensures password confirmation\n    matches, updates the user's password, and invalidates the code.\n\n    Args:\n        request (ForgotPasswordConfirmation): Confirmation payload with code and new password.\n\n    Returns:\n        Dict[str, str]: Confirmation message.\n\n    Raises:\n        HTTPException: 404 if code is invalid or expired, or user not found.\n        HTTPException: 400 if passwords do not match.\n    \"\"\"\n    forgot_password = await ForgotPassword.find_one({\"code\": request.code})\n    if not forgot_password:\n        raise HTTPException(status_code=404, detail=\"Invalid code\")\n\n    current_time = datetime.now(timezone.utc)\n    expires_at = forgot_password.expires_at\n\n    if expires_at.tzinfo is None:\n        expires_at = expires_at.replace(tzinfo=timezone.utc)\n\n    if not forgot_password or expires_at &lt; current_time:\n        raise HTTPException(status_code=404, detail=\"Invalid code\")\n\n    if request.new_password != request.confirm_password:\n        raise HTTPException(status_code=400, detail=\"Passwords do not match\")\n\n    user = await User.find_one({\"email\": forgot_password.email})\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    user.password_hash = hash_password(request.new_password)\n    await user.save()\n    await forgot_password.delete()\n    return {\"message\": \"Password changed\"}\n</code></pre>"},{"location":"routers-health_check/","title":"Health Check","text":""},{"location":"routers-health_check/#routers.health_check","title":"<code>health_check</code>","text":""},{"location":"routers-health_check/#routers.health_check.health_check","title":"<code>health_check()</code>","text":"<p>Liveness probe endpoint.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Static status payload indicating service health.</p> Source code in <code>src/routers/health_check.py</code> <pre><code>@router.get(\"/health\")\ndef health_check():\n    \"\"\"Liveness probe endpoint.\n\n    Returns:\n        dict: Static status payload indicating service health.\n    \"\"\"\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"routers-message/","title":"Message","text":""},{"location":"routers-message/#routers.message","title":"<code>message</code>","text":""},{"location":"routers-message/#routers.message.get_average_latencies","title":"<code>get_average_latencies(start_date: datetime | None = None, end_date: datetime | None = None) -&gt; dict</code>  <code>async</code>","text":"<p>Return average latencies aggregated across all messages.</p> <p>Optionally filters the aggregation by a timestamp window.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime | None</code> <p>Optional start of the time window (inclusive).</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>Optional end of the time window (inclusive).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping of latency metric name to average value.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>500 for server errors during aggregation.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.get(\"/conversations/messages/average-latencies\")\nasync def get_average_latencies(\n    start_date: datetime | None = None, end_date: datetime | None = None\n) -&gt; dict:\n    \"\"\"\n    Return average latencies aggregated across all messages.\n\n    Optionally filters the aggregation by a timestamp window.\n\n    Args:\n        start_date (datetime | None): Optional start of the time window (inclusive).\n        end_date (datetime | None): Optional end of the time window (inclusive).\n\n    Returns:\n        Mapping of latency metric name to average value.\n\n    Raises:\n        HTTPException: 500 for server errors during aggregation.\n    \"\"\"\n    try:\n        messages_col = Message.get_collection()\n        pipeline = []\n        if start_date is not None or end_date is not None:\n            time_filter = {}\n            if start_date is not None:\n                time_filter[\"$gte\"] = start_date\n            if end_date is not None:\n                time_filter[\"$lte\"] = end_date\n            pipeline.append({\"$match\": {\"timestamp\": time_filter}})\n        pipeline.append(\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"rag_decision_latency\": {\n                        \"$avg\": \"$metadata.latencies.rag_decision_latency\"\n                    },\n                    \"query_embedding_latency\": {\n                        \"$avg\": \"$metadata.latencies.query_embedding_latency\"\n                    },\n                    \"qdrant_retrieval_latency\": {\n                        \"$avg\": \"$metadata.latencies.qdrant_retrieval_latency\"\n                    },\n                    \"mcp_retrieval_latency\": {\n                        \"$avg\": \"$metadata.latencies.mcp_retrieval_latency\"\n                    },\n                    \"reranking_latency\": {\n                        \"$avg\": \"$metadata.latencies.reranking_latency\"\n                    },\n                    \"first_token_latency\": {\n                        \"$avg\": \"$metadata.latencies.first_token_latency\"\n                    },\n                    \"mistral_first_token_latency\": {\n                        \"$avg\": \"$metadata.latencies.mistral_first_token_latency\"\n                    },\n                    \"base_generation_latency\": {\n                        \"$avg\": \"$metadata.latencies.base_generation_latency\"\n                    },\n                }\n            }\n        )\n        cursor = messages_col.aggregate(pipeline, allowDiskUse=True)\n        results = await cursor.to_list(length=1)\n        return results[0]\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.get_my_message_stats","title":"<code>get_my_message_stats(requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Return counts and character totals for the current user's messages.</p> <p>Aggregates across all messages belonging to conversations owned by the user.</p> <p>Parameters:</p> Name Type Description Default <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Aggregated stats including counts and character sums.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>500 for server errors during aggregation.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.get(\"/conversations/messages/me/stats\")\nasync def get_my_message_stats(requesting_user: User = Depends(get_current_user)) -&gt; dict:\n    \"\"\"\n    Return counts and character totals for the current user's messages.\n\n    Aggregates across all messages belonging to conversations owned by the user.\n\n    Args:\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Aggregated stats including counts and character sums.\n\n    Raises:\n        HTTPException: 500 for server errors during aggregation.\n    \"\"\"\n    try:\n        messages_col = Message.get_collection()\n\n        # Fetch conversation IDs owned by the current user (avoid $lookup pipelines unsupported by DocumentDB)\n        user_conversations = await Conversation.find_all(\n            filter_dict={\"user_id\": requesting_user.id}\n        )\n        conversation_ids = [c.id for c in user_conversations if getattr(c, \"id\", None)]\n\n        if not conversation_ids:\n            return {\n                \"message_count\": 0,\n                \"input_characters\": 0,\n                \"output_characters\": 0,\n                \"total_characters\": 0,\n            }\n\n        pipeline = [\n            {\"$match\": {\"conversation_id\": {\"$in\": conversation_ids}}},\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"message_count\": {\"$sum\": 1},\n                    \"input_characters\": {\n                        \"$sum\": {\n                            \"$strLenCP\": {\n                                \"$ifNull\": [\n                                    \"$metadata.prompts.generation_prompt\",\n                                    \"\",\n                                ]\n                            }\n                        }\n                    },\n                    \"output_characters\": {\n                        \"$sum\": {\"$strLenCP\": {\"$ifNull\": [\"$output\", \"\"]}}\n                    },\n                }\n            },\n            {\n                \"$project\": {\n                    \"_id\": 0,\n                    \"message_count\": 1,\n                    \"input_characters\": 1,\n                    \"output_characters\": 1,\n                    \"total_characters\": {\n                        \"$add\": [\"$input_characters\", \"$output_characters\"],\n                    },\n                }\n            },\n        ]\n\n        cursor = messages_col.aggregate(pipeline, allowDiskUse=True)\n        results = await cursor.to_list(length=1)\n\n        if results:\n            return results[0]\n\n        return {\n            \"message_count\": 0,\n            \"input_characters\": 0,\n            \"output_characters\": 0,\n            \"total_characters\": 0,\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.create_message","title":"<code>create_message(request: GenerationRequest, conversation_id: str, background_tasks: BackgroundTasks, requesting_user: User = Depends(get_current_user)) -&gt; CreateMessageResponse</code>  <code>async</code>","text":"<p>Create a new message in a conversation and generate an answer.</p> <p>Validates conversation ownership, normalizes requested public collections, persists a placeholder <code>Message</code>, runs generation, updates the message with answer and retrieval metadata, and schedules rollup/trimming of history.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>GenerationRequest</code> <p>Generation parameters including query, collections, and model settings.</p> required <code>conversation_id</code> <code>str</code> <p>Target conversation identifier.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Background task runner used to schedule rollups.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>CreateMessageResponse</code> <p>Message id, query, answer, documents, flags, and metadata.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation is not found; 403 if ownership/collections invalid; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\n    \"/conversations/{conversation_id}/messages\", response_model=CreateMessageResponse\n)\nasync def create_message(\n    request: GenerationRequest,\n    conversation_id: str,\n    background_tasks: BackgroundTasks,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; CreateMessageResponse:\n    \"\"\"\n    Create a new message in a conversation and generate an answer.\n\n    Validates conversation ownership, normalizes requested public collections, persists a placeholder `Message`, runs generation, updates the message with answer and retrieval metadata, and schedules rollup/trimming of history.\n\n    Args:\n        request (GenerationRequest): Generation parameters including query, collections, and model settings.\n        conversation_id (str): Target conversation identifier.\n        background_tasks (BackgroundTasks): Background task runner used to schedule rollups.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Message id, query, answer, documents, flags, and metadata.\n\n    Raises:\n        HTTPException: 404 if conversation is not found; 403 if ownership/collections invalid; 500 for server errors.\n    \"\"\"\n    message = None\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to add a message to this conversation\",\n            )\n\n        # Normalize and validate requested public collections against allowed lists\n        allowed_source = PUBLIC_COLLECTIONS if IS_PROD else STAGING_PUBLIC_COLLECTIONS\n        try:\n            allowed_names = {\n                item.get(\"name\")\n                for item in (allowed_source + WILEY_PUBLIC_COLLECTIONS)\n                if isinstance(item, dict) and item.get(\"name\")\n            }\n        except Exception:\n            allowed_names = set()\n\n        public_collections = [\n            n for n in request.public_collections if n in allowed_names\n        ]\n        request.public_collections = public_collections\n\n        # lookup query to check if some of the collection ids from other users are in the request.collection_ids\n        other_users_collections = await CollectionModel.find_all(\n            filter_dict={\n                \"id\": {\"$in\": request.public_collections},\n                \"user_id\": {\"$ne\": requesting_user.id},\n            }\n        )\n\n        if len(other_users_collections) &gt; 0:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to use collections from other users\",\n            )\n\n        request.collection_ids = request.collection_ids + request.public_collections\n\n        # All user collections are used by default\n        user_collections = await CollectionModel.find_all(\n            filter_dict={\"user_id\": requesting_user.id}\n        )\n\n        request.private_collections_map = {c.id: c.name for c in user_collections}\n        if len(user_collections) &gt; 0:\n            request.collection_ids = request.collection_ids + [\n                c.id for c in user_collections\n            ]\n        # remove \"Wiley AI Gateway\" from collection_ids\n        request.collection_ids = [\n            c for c in request.collection_ids if c != \"Wiley AI Gateway\"\n        ]\n        logger.info(f\"Collection IDs: {request.collection_ids}\")\n\n        # Extract year range from filters for MCP usage\n        try:\n            request.year = extract_year_range_from_filters(request.filters)\n        except Exception:\n            request.year = None\n\n        message = await Message.create(\n            conversation_id=conversation_id,\n            input=request.query,\n            output=\"\",\n            documents=[],\n            use_rag=False,\n            request_input=request,\n            metadata={},\n        )\n\n        answer, results, is_rag, latencies, prompts, retrieved_docs = (\n            await generate_answer(request, conversation_id=conversation_id)\n        )\n\n        documents_data = []\n        if results:\n            documents_data = [extract_document_data(result) for result in results]\n\n        message.output = answer\n        message.documents = documents_data\n        message.use_rag = is_rag\n        existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n        existing_metadata.update(\n            {\n                \"latencies\": latencies,\n                \"prompts\": prompts,\n                \"retrieved_docs\": retrieved_docs,\n            }\n        )\n        message.metadata = existing_metadata\n        await message.save()\n\n        # Schedule rollup as background task to avoid blocking response\n        background_tasks.add_task(maybe_rollup_and_trim_history, conversation_id)\n\n        return {\n            \"id\": message.id,\n            \"query\": request.query,\n            \"answer\": answer,\n            \"documents\": documents_data,\n            \"use_rag\": is_rag,\n            \"conversation_id\": conversation_id,\n            \"collection_ids\": request.collection_ids,\n            \"metadata\": {\n                \"latencies\": latencies,\n            },\n        }\n    except HTTPException as http_exc:\n        if message:\n            try:\n                existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n                existing_metadata[\"error\"] = str(getattr(http_exc, \"detail\", http_exc))\n                message.metadata = existing_metadata\n                await message.save()\n            except Exception:\n                pass\n        raise\n    except Exception as e:\n        if message:\n            try:\n                existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n                existing_metadata[\"error\"] = str(e)\n                message.metadata = existing_metadata\n                await message.save()\n            except Exception:\n                pass\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.retry","title":"<code>retry(conversation_id: str, message_id: str, background_tasks: BackgroundTasks, requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Retry generation for an existing message.</p> <p>Re-validates conversation ownership and message relationship, reuses the original <code>request_input</code> stored on the message, regenerates the answer, and updates message content, documents, and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>message_id</code> <code>str</code> <p>Message identifier to retry.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Background task runner used to schedule rollups.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Response payload mirroring create_message with updated answer and metadata.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation/message not found; 403 if ownership invalid; 400 if message cannot be retried; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\"/conversations/{conversation_id}/messages/{message_id}/retry\")\nasync def retry(\n    conversation_id: str,\n    message_id: str,\n    background_tasks: BackgroundTasks,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Retry generation for an existing message.\n\n    Re-validates conversation ownership and message relationship, reuses the original `request_input` stored on the message, regenerates the answer, and updates message content, documents, and metadata.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        message_id (str): Message identifier to retry.\n        background_tasks (BackgroundTasks): Background task runner used to schedule rollups.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Response payload mirroring create_message with updated answer and metadata.\n\n    Raises:\n        HTTPException: 404 if conversation/message not found; 403 if ownership invalid; 400 if message cannot be retried; 500 for server errors.\n    \"\"\"\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to add a message to this conversation\",\n            )\n\n        message = await Message.find_by_id(message_id)\n        if not message:\n            raise HTTPException(status_code=404, detail=\"Message not found\")\n\n        if message.conversation_id != conversation_id:\n            raise HTTPException(\n                status_code=404, detail=\"Message not found in this conversation\"\n            )\n\n        if not message.request_input:\n            raise HTTPException(\n                status_code=400,\n                detail=\"This message cannot be retried\",\n            )\n\n        answer, results, is_rag, latencies, prompts, retrieved_docs = (\n            await generate_answer(\n                message.request_input, conversation_id=conversation_id\n            )\n        )\n\n        documents_data = []\n        if results:\n            documents_data = [extract_document_data(result) for result in results]\n\n        message.output = answer\n        message.documents = documents_data\n        message.use_rag = is_rag\n        existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n        existing_metadata.update(\n            {\n                \"latencies\": latencies,\n                \"prompts\": prompts,\n                \"retrieved_docs\": retrieved_docs,\n            }\n        )\n        message.metadata = existing_metadata\n        await message.save()\n\n        # Schedule rollup as background task to avoid blocking response\n        background_tasks.add_task(maybe_rollup_and_trim_history, conversation_id)\n\n        return {\n            \"id\": message.id,\n            \"query\": message.input,\n            \"answer\": answer,\n            \"documents\": documents_data,\n            \"use_rag\": is_rag,\n            \"conversation_id\": conversation_id,\n            \"collection_ids\": message.request_input.collection_ids,\n            \"metadata\": {\n                \"latencies\": latencies,\n                \"prompts\": prompts,\n                \"retrieved_docs\": retrieved_docs,\n            },\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.update_message","title":"<code>update_message(conversation_id: str, message_id: str, request: MessageUpdate, requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Update message feedback and related annotations.</p> <p>Supports updating fields such as <code>feedback</code>, <code>feedback_reason</code>, <code>was_copied</code>, and hallucination feedback metadata on the target message.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>message_id</code> <code>str</code> <p>Message identifier to update.</p> required <code>request</code> <code>MessageUpdate</code> <p>Partial update payload for feedback fields.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Success message upon update.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation/message not found or mismatched; 403 if ownership invalid; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.patch(\"/conversations/{conversation_id}/messages/{message_id}\")\nasync def update_message(\n    conversation_id: str,\n    message_id: str,\n    request: MessageUpdate,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Update message feedback and related annotations.\n\n    Supports updating fields such as `feedback`, `feedback_reason`, `was_copied`, and hallucination feedback metadata on the target message.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        message_id (str): Message identifier to update.\n        request (MessageUpdate): Partial update payload for feedback fields.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Success message upon update.\n\n    Raises:\n        HTTPException: 404 if conversation/message not found or mismatched; 403 if ownership invalid; 500 for server errors.\n    \"\"\"\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        message = await Message.find_by_id(message_id)\n        if not message:\n            raise HTTPException(status_code=404, detail=\"Message not found\")\n\n        if message.conversation_id != conversation_id:\n            raise HTTPException(\n                status_code=404, detail=\"Message not found in this conversation\"\n            )\n\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to update feedback for this message\",\n            )\n\n        if request.feedback is not None:\n            message.feedback = request.feedback.value\n\n        if request.was_copied is not None:\n            message.was_copied = request.was_copied\n\n        if request.feedback_reason is not None:\n            message.feedback_reason = request.feedback_reason\n\n        if request.hallucination_feedback is not None:\n            if message.hallucination is None:\n                message.hallucination = {}\n            message.hallucination[\"feedback\"] = request.hallucination_feedback.value\n\n        if request.hallucination_feedback_reason is not None:\n            if message.hallucination is None:\n                message.hallucination = {}\n            message.hallucination[\"feedback_reason\"] = (\n                request.hallucination_feedback_reason\n            )\n\n        if request.hallucination_was_copied is not None:\n            if message.hallucination is None:\n                message.hallucination = {}\n            message.hallucination[\"was_copied\"] = request.hallucination_was_copied\n\n        await message.save()\n\n        return {\"message\": \"Feedback updated successfully\"}\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.create_message_stream","title":"<code>create_message_stream(request: GenerationRequest, conversation_id: str, background_tasks: BackgroundTasks, requesting_user: User = Depends(get_current_user)) -&gt; StreamingResponse</code>  <code>async</code>","text":"<p>Create a new message and stream generation via Server-Sent Events (SSE).</p> <p>Sets up a per-message stream bus and runs generation in a decoupled task. Yields SSE-formatted chunks including status updates, tokens, and final payloads.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>GenerationRequest</code> <p>Generation parameters including query, collections, and model settings.</p> required <code>conversation_id</code> <code>str</code> <p>Target conversation identifier.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Background task runner used to schedule rollups.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>StreamingResponse</code> <p>SSE stream for the generation lifecycle.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation is not found; 403 if ownership/collections invalid; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\n    \"/conversations/{conversation_id}/stream_messages\",\n    response_class=StreamingResponse,\n)\nasync def create_message_stream(\n    request: GenerationRequest,\n    conversation_id: str,\n    background_tasks: BackgroundTasks,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; StreamingResponse:\n    \"\"\"\n    Create a new message and stream generation via Server-Sent Events (SSE).\n\n    Sets up a per-message stream bus and runs generation in a decoupled task. Yields SSE-formatted chunks including status updates, tokens, and final payloads.\n\n    Args:\n        request (GenerationRequest): Generation parameters including query, collections, and model settings.\n        conversation_id (str): Target conversation identifier.\n        background_tasks (BackgroundTasks): Background task runner used to schedule rollups.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        SSE stream for the generation lifecycle.\n\n    Raises:\n        HTTPException: 404 if conversation is not found; 403 if ownership/collections invalid; 500 for server errors.\n    \"\"\"\n    message = None\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to add a message to this conversation\",\n            )\n\n        # Normalize and validate requested public collections against allowed lists\n        allowed_source = PUBLIC_COLLECTIONS if IS_PROD else STAGING_PUBLIC_COLLECTIONS\n        try:\n            allowed_names = {\n                item.get(\"name\")\n                for item in (allowed_source + WILEY_PUBLIC_COLLECTIONS)\n                if isinstance(item, dict) and item.get(\"name\")\n            }\n        except Exception:\n            allowed_names = set()\n\n        public_collections = [\n            n for n in request.public_collections if n in allowed_names\n        ]\n        request.public_collections = public_collections\n\n        # lookup query to check if some of the collection ids from other users are in the request.collection_ids\n        other_users_collections = await CollectionModel.find_all(\n            filter_dict={\n                \"id\": {\"$in\": request.public_collections},\n                \"user_id\": {\"$ne\": requesting_user.id},\n            }\n        )\n\n        if len(other_users_collections) &gt; 0:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to use collections from other users\",\n            )\n\n        request.collection_ids = request.collection_ids + request.public_collections\n\n        # All user collections are used by default\n        user_collections = await CollectionModel.find_all(\n            filter_dict={\"user_id\": requesting_user.id}\n        )\n\n        request.private_collections_map = {c.id: c.name for c in user_collections}\n        if len(user_collections) &gt; 0:\n            request.collection_ids = request.collection_ids + [\n                c.id for c in user_collections\n            ]\n        # remove \"Wiley AI Gateway\" from collection_ids\n        request.collection_ids = [\n            c for c in request.collection_ids if c != \"Wiley AI Gateway\"\n        ]\n        logger.info(f\"Collection IDs: {request.collection_ids}\")\n\n        # Extract year range from filters for MCP usage\n        try:\n            request.year = extract_year_range_from_filters(request.filters)\n        except Exception:\n            request.year = None\n\n        message = await Message.create(\n            conversation_id=conversation_id,\n            input=request.query,\n            output=\"\",\n            documents=[],\n            use_rag=False,\n            request_input=request,\n            metadata={},\n        )\n\n        # Start decoupled background job that publishes to bus\n        cancel_mgr = get_cancel_manager()\n        cancel_event = cancel_mgr.create(message.id)\n        cancel_mgr.link_conversation(conversation_id, message.id)\n        gen_task = asyncio.create_task(\n            run_generation_to_bus(\n                request=request,\n                conversation_id=conversation_id,\n                message_id=message.id,\n                background_tasks=background_tasks,\n                cancel_event=cancel_event,\n            )\n        )\n        cancel_mgr.set_task(message.id, gen_task)\n\n        bus = get_stream_bus()\n\n        async def _gen():\n            # Optional catch-up from currently saved output (usually empty right after create)\n            try:\n                if message.output:\n                    yield f\"data: {json.dumps({'type':'partial','content': message.output})}\\n\\n\"\n            except Exception:\n                pass\n            async for data in bus.subscribe(message.id):\n                yield data\n\n        response = StreamingResponse(_gen(), media_type=\"text/event-stream\")\n        # Set SSE-friendly headers to prevent proxy/client reconnect loops\n        response.headers[\"Cache-Control\"] = \"no-cache\"\n        response.headers[\"Connection\"] = \"keep-alive\"\n        response.headers[\"X-Accel-Buffering\"] = \"no\"  # Nginx buffering off if present\n        return response\n    except HTTPException as http_exc:\n        if message:\n            try:\n                existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n                existing_metadata[\"error\"] = str(getattr(http_exc, \"detail\", http_exc))\n                message.metadata = existing_metadata\n                await message.save()\n            except Exception:\n                pass\n        raise\n    except Exception as e:\n        if message:\n            try:\n                existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n                existing_metadata[\"error\"] = str(e)\n                message.metadata = existing_metadata\n                await message.save()\n            except Exception:\n                pass\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.stop_conversation","title":"<code>stop_conversation(conversation_id: str, requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Signal cancellation for the active generation within a conversation.</p> <p>Uses the cancel manager to locate the in-flight message/task and requests cooperative cancellation, also notifying downstream subscribers via the stream bus.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier to stop generation for.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Status payload indicating stop state or absence of active generation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation is not found; 403 if ownership invalid; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\"/conversations/{conversation_id}/stop\")\nasync def stop_conversation(\n    conversation_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Signal cancellation for the active generation within a conversation.\n\n    Uses the cancel manager to locate the in-flight message/task and requests cooperative cancellation, also notifying downstream subscribers via the stream bus.\n\n    Args:\n        conversation_id (str): Conversation identifier to stop generation for.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Status payload indicating stop state or absence of active generation.\n\n    Raises:\n        HTTPException: 404 if conversation is not found; 403 if ownership invalid; 500 for server errors.\n    \"\"\"\n    try:\n        logger.info(\n            \"generation.stop.requested user_id=%s conversation_id=%s\",\n            requesting_user.id,\n            conversation_id,\n        )\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n        if conversation.user_id != requesting_user.id:\n            raise HTTPException(\n                status_code=403,\n                detail=\"You are not allowed to access this conversation\",\n            )\n\n        cancel_mgr = get_cancel_manager()\n        # Prefer async lookup to support Redis-backed mapping across workers\n        try:\n            message_id = await cancel_mgr.get_message_for_conversation_async(conversation_id)  # type: ignore\n        except Exception:\n            message_id = cancel_mgr.get_message_for_conversation(conversation_id)\n        if not message_id:\n            # Nothing active to stop; respond success for idempotency\n            logger.info(\n                \"generation.stop.no_active user_id=%s conversation_id=%s\",\n                requesting_user.id,\n                conversation_id,\n            )\n            return {\"status\": \"no_active_generation\"}\n\n        cancel_mgr.cancel(message_id)\n        try:\n            bus = get_stream_bus()\n            await bus.publish(message_id, f\"data: {json.dumps({'type':'stopped'})}\\n\\n\")\n            await bus.close(message_id)\n            logger.info(\n                \"generation.stop.signaled user_id=%s conversation_id=%s message_id=%s\",\n                requesting_user.id,\n                conversation_id,\n                message_id,\n            )\n        except Exception as e:\n            logger.warning(\n                \"generation.stop.signal_failed conversation_id=%s message_id=%s err=%s\",\n                conversation_id,\n                message_id,\n                str(e),\n            )\n        return {\"status\": \"stopping\", \"message_id\": message_id}\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.get_source_logs","title":"<code>get_source_logs(conversation_id: str, message_id: str, request: SourceLogsRequest, requesting_user: User = Depends(get_current_user)) -&gt; dict</code>  <code>async</code>","text":"<p>Append a source log entry to a message's metadata.</p> <p>Stores user-attributed source inspection information such as id, url, title, and collection name, with a server-side timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>message_id</code> <code>str</code> <p>Message identifier.</p> required <code>request</code> <code>SourceLogsRequest</code> <p>Source log details to append.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>dict</code> <p>Confirmation message upon successful append.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation/message not found or mismatched; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\"/conversations/{conversation_id}/messages/{message_id}/source_logs\")\nasync def get_source_logs(\n    conversation_id: str,\n    message_id: str,\n    request: SourceLogsRequest,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; dict:\n    \"\"\"\n    Append a source log entry to a message's metadata.\n\n    Stores user-attributed source inspection information such as id, url, title, and collection name, with a server-side timestamp.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        message_id (str): Message identifier.\n        request (SourceLogsRequest): Source log details to append.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Confirmation message upon successful append.\n\n    Raises:\n        HTTPException: 404 if conversation/message not found or mismatched; 500 for server errors.\n    \"\"\"\n    try:\n        conversation = await Conversation.find_by_id(conversation_id)\n        if not conversation:\n            raise HTTPException(status_code=404, detail=\"Conversation not found\")\n\n        message = await Message.find_by_id(message_id)\n        if not message:\n            raise HTTPException(status_code=404, detail=\"Message not found\")\n\n        if message.conversation_id != conversation_id:\n            raise HTTPException(\n                status_code=404, detail=\"Message not found in this conversation\"\n            )\n\n        # store source logs as an array and append each new entry\n        existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n        source_logs = list(existing_metadata.get(\"source_logs\") or [])\n        source_logs.append(\n            {\n                **request.model_dump(),\n                \"timestamp\": datetime.now().isoformat(),\n                \"user_id\": requesting_user.id,\n            }\n        )\n        existing_metadata[\"source_logs\"] = source_logs\n        message.metadata = existing_metadata\n        await message.save()\n        return {\"message\": \"Source logs stored successfully\"}\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.hallucination_detect","title":"<code>hallucination_detect(conversation_id: str, message_id: str, requesting_user: User = Depends(get_current_user)) -&gt; HallucinationDetectResponse</code>  <code>async</code>","text":"<p>Detect and persist hallucination analysis for a message.</p> <p>Runs a multi-step pipeline (detect, optionally rewrite, retrieve, answer) and stores the result and latency breakdown on the message metadata.</p> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>message_id</code> <code>str</code> <p>Message identifier to analyze.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>HallucinationDetectResponse</code> <p>Structured hallucination analysis with optional final answer.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation/message not found or mismatched; 403 if ownership invalid; 500 for server errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\n    \"/conversations/{conversation_id}/messages/{message_id}/hallucination\",\n    response_model=HallucinationDetectResponse,\n)\nasync def hallucination_detect(\n    conversation_id: str,\n    message_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; HallucinationDetectResponse:\n    \"\"\"\n    Detect and persist hallucination analysis for a message.\n\n    Runs a multi-step pipeline (detect, optionally rewrite, retrieve, answer) and stores the result and latency breakdown on the message metadata.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        message_id (str): Message identifier to analyze.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Structured hallucination analysis with optional final answer.\n\n    Raises:\n        HTTPException: 404 if conversation/message not found or mismatched; 403 if ownership invalid; 500 for server errors.\n    \"\"\"\n    # Validate conversation ownership and message relationship\n    conversation = await Conversation.find_by_id(conversation_id)\n    if not conversation:\n        raise HTTPException(status_code=404, detail=\"Conversation not found\")\n    if conversation.user_id != requesting_user.id:\n        raise HTTPException(\n            status_code=403,\n            detail=\"You are not allowed to access this conversation\",\n        )\n\n    message = await Message.find_by_id(message_id)\n    if not message:\n        raise HTTPException(status_code=404, detail=\"Message not found\")\n    if message.conversation_id != conversation_id:\n        raise HTTPException(\n            status_code=400, detail=\"Message does not belong to this conversation\"\n        )\n\n    try:\n        total_start = time.perf_counter()\n        detector = HallucinationDetector()\n\n        (\n            label,\n            reason,\n            _orig_q,\n            rewritten_question,\n            final_answer,\n            latencies,\n        ) = await detector.run(\n            query=message.input,\n            model_response=message.output,\n            docs=build_context(message.documents),\n            llm_type=message.request_input.llm_type,\n        )\n        total_latency = time.perf_counter() - total_start\n\n        # Persist hallucination result to Message\n        try:\n            existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n            hallucination_payload = {\n                \"label\": label,\n                \"reason\": reason,\n                \"rewritten_question\": rewritten_question,\n                \"final_answer\": final_answer,\n                \"latencies\": {\n                    \"detect\": latencies.get(\"detect\") if latencies else None,\n                    \"rewrite\": latencies.get(\"rewrite\") if latencies else None,\n                    \"final_answer\": (\n                        latencies.get(\"final_answer\") if latencies else None\n                    ),\n                    \"total\": total_latency,\n                },\n            }\n            existing_metadata[\"hallucination\"] = hallucination_payload\n            message.metadata = existing_metadata\n            await message.save()\n        except HTTPException:\n            raise\n        except Exception as e:\n            logger.error(f\"Failed to update Message with hallucination result: {e}\")\n\n        return HallucinationDetectResponse(\n            label=label,\n            reason=reason,\n            original_question=message.input,\n            rewritten_question=rewritten_question,\n            final_answer=final_answer,\n            latencies=latencies,\n        )\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Hallucination detection failed: {e}\", exc_info=True)\n        raise HTTPException(status_code=500, detail=f\"Server error: {str(e)}\")\n</code></pre>"},{"location":"routers-message/#routers.message.stream_hallucination","title":"<code>stream_hallucination(conversation_id: str, message_id: str, requesting_user: User = Depends(get_current_user)) -&gt; StreamingResponse</code>  <code>async</code>","text":"<p>Stream hallucination handling result as Server-Sent Events (SSE).</p> <p>Streams structured events for detection, optional rewriting, retrieval, and answer generation steps.</p> <ul> <li>If label == 0 (factual), emits a final event with the reason.</li> <li>If label == 1 (hallucination), streams tokens for the final answer and then a final event.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>conversation_id</code> <code>str</code> <p>Conversation identifier.</p> required <code>message_id</code> <code>str</code> <p>Message identifier to analyze.</p> required <code>requesting_user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>StreamingResponse</code> <p>SSE events for the detection workflow.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if conversation/message not found or mismatched; 403 if access is forbidden; 500 for streaming errors.</p> Source code in <code>src/routers/message.py</code> <pre><code>@router.post(\n    \"/conversations/{conversation_id}/messages/{message_id}/stream-hallucination\",\n    response_class=StreamingResponse,\n)\nasync def stream_hallucination(\n    conversation_id: str,\n    message_id: str,\n    requesting_user: User = Depends(get_current_user),\n) -&gt; StreamingResponse:\n    \"\"\"\n    Stream hallucination handling result as Server-Sent Events (SSE).\n\n    Streams structured events for detection, optional rewriting, retrieval, and answer generation steps.\n\n    - If label == 0 (factual), emits a final event with the reason.\n    - If label == 1 (hallucination), streams tokens for the final answer and then a final event.\n\n    Args:\n        conversation_id (str): Conversation identifier.\n        message_id (str): Message identifier to analyze.\n        requesting_user (User): Authenticated user injected by dependency.\n\n    Returns:\n        SSE events for the detection workflow.\n\n    Raises:\n        HTTPException: 404 if conversation/message not found or mismatched; 403 if access is forbidden; 500 for streaming errors.\n    \"\"\"\n    # Validate conversation ownership and message relationship\n    conversation = await Conversation.find_by_id(conversation_id)\n    if not conversation:\n        raise HTTPException(status_code=404, detail=\"Conversation not found\")\n    if conversation.user_id != requesting_user.id:\n        raise HTTPException(\n            status_code=403,\n            detail=\"You are not allowed to access this conversation\",\n        )\n\n    message = await Message.find_by_id(message_id)\n    if not message:\n        raise HTTPException(status_code=404, detail=\"Message not found\")\n    if message.conversation_id != conversation_id:\n        raise HTTPException(\n            status_code=400, detail=\"Message does not belong to this conversation\"\n        )\n\n    async def _generator():\n        import json\n        import time\n        from src.utils.template_loader import get_template\n\n        total_start = time.perf_counter()\n        detector = HallucinationDetector()\n        try:\n            # Emit an initial status event early to start the stream promptly\n            yield f\"data: {json.dumps({'type': 'status', 'content': 'hallucination detection started...'})}\\n\\n\"\n            # Step 1: Detect\n            t0 = time.perf_counter()\n            label, reason = await detector.detect(\n                query=message.input,\n                model_response=message.output,\n                docs=build_context(message.documents),\n                llm_type=message.request_input.llm_type,\n            )\n            detect_latency = time.perf_counter() - t0\n\n            yield f\"data: {json.dumps({'type': 'label', 'content': label})}\\n\\n\"\n            yield f\"data: {json.dumps({'type': 'reason', 'content': reason})}\\n\\n\"\n\n            # If factual (label == 0), emit reason and finish\n            if label == 0:\n                total_latency = time.perf_counter() - total_start\n                latencies = {\n                    \"detect\": detect_latency,\n                    \"rewrite\": None,\n                    \"final_answer\": None,\n                    \"total\": total_latency,\n                }\n                # Persist to message metadata\n                try:\n                    message.hallucination = {\n                        \"label\": label,\n                        \"reason\": reason,\n                        \"rewritten_question\": None,\n                        \"final_answer\": None,\n                        \"latencies\": latencies,\n                    }\n                    await message.save()\n                except Exception:\n                    pass\n\n                final_payload = {\n                    \"type\": \"final\",\n                    \"label\": label,\n                    \"reason\": reason,\n                    \"rewritten_question\": None,\n                    \"answer\": None,\n                    \"latencies\": latencies,\n                    \"top_k_retrieved_docs\": None,\n                }\n                yield f\"data: {json.dumps(final_payload)}\\n\\n\"\n                return\n\n            # Step 2: Rewrite (for hallucination)\n            # Transparency: emit rewriting step\n            yield f\"data: {json.dumps({'type': 'status', 'content': 'Rewriting query...'})}\\n\\n\"\n            t1 = time.perf_counter()\n            _orig_q, rewritten_question = await detector.rewrite_query(\n                query=message.input,\n                answer=message.output,\n                reason=reason,\n                llm_type=message.request_input.llm_type,\n            )\n            rewrite_latency = time.perf_counter() - t1\n            yield f\"data: {json.dumps({'type': 'rewritten_question', 'content': rewritten_question})}\\n\\n\"\n\n            # Step 3: Retrieve docs for rewritten_question (Qdrant + Wiley MCP)\n            # Transparency: emit retrieving step\n            yield f\"data: {json.dumps({'type': 'status', 'content': 'Retrieving relevant documents...'})}\\n\\n\"\n            # Build a new GenerationRequest based on original, overriding the query\n            req_in = message.request_input or GenerationRequest(query=message.input)\n            rewritten_request = GenerationRequest(\n                query=rewritten_question or message.input,\n                year=getattr(req_in, \"year\", None),\n                filters=getattr(req_in, \"filters\", None),\n                llm_type=getattr(req_in, \"llm_type\", None),\n                embeddings_model=getattr(req_in, \"embeddings_model\", None),\n                k=getattr(req_in, \"k\", 5),\n                temperature=getattr(req_in, \"temperature\", 0.3),\n                score_threshold=getattr(req_in, \"score_threshold\", 0.7),\n                max_new_tokens=getattr(req_in, \"max_new_tokens\", 1024),\n                public_collections=list(\n                    getattr(req_in, \"public_collections\", []) or []\n                ),\n            )\n            try:\n                rewritten_request.collection_ids = list(\n                    getattr(req_in, \"collection_ids\", []) or []\n                )\n            except Exception:\n                pass\n            try:\n                rewritten_request.private_collections_map = dict(\n                    getattr(req_in, \"private_collections_map\", {}) or {}\n                )\n            except Exception:\n                pass\n\n            context = \"\"\n            retrieved_docs = []\n            rag_latencies = {}\n            try:\n                context, results, rag_latencies, retrieved_docs = (\n                    await setup_rag_and_context(rewritten_request)\n                )\n            except Exception as e:\n                # Soft-fail RAG retrieval; proceed without new docs\n                rag_latencies = {\"rag_error\": str(e)}\n                retrieved_docs = []\n                context = \"\"\n\n            # Step 4: Stream final answer from LLM using the hallucination answer template\n            template = get_template(\n                \"llm_answer_template\", filename=\"hallucination_detector.yaml\"\n            )\n            # Inject retrieved context for better grounding\n            prompt = template.format(query=rewritten_question or message.input)\n            if context:\n                prompt = f\"{prompt}\\n\\nContext:\\n{context}\"\n\n            yield f\"data: {json.dumps({'type': 'status', 'content': 'Generating answer...'})}\\n\\n\"\n            final_answer_chunks = []\n            t2 = time.perf_counter()\n            # Try primary provider streaming first with a first-token timeout, then fallback to Mistral\n            llm = detector.llm_manager.get_client_for_model(\n                message.request_input.llm_type\n            )\n            used_stream = False\n            try:\n                astream = llm.astream(prompt)\n                # Enforce first token timeout similar to generate_answer\n                llm_instruct_timeout = (\n                    detector.llm_manager.config.get_instruct_llm_timeout()\n                )\n                async with asyncio.timeout(llm_instruct_timeout):\n                    first = await astream.__anext__()\n                    first_text = getattr(first, \"content\", None)\n                    if first_text:\n                        final_answer_chunks.append(first_text)\n                        yield f\"data: {json.dumps({'type':'token','content':first_text})}\\n\\n\"\n                # Continue without timeout\n                async for token in astream:\n                    text = getattr(token, \"content\", None)\n                    if not text:\n                        continue\n                    final_answer_chunks.append(text)\n                    yield f\"data: {json.dumps({'type':'token','content':text})}\\n\\n\"\n                used_stream = True\n            except Exception:\n                used_stream = False\n\n            # Fallback to Mistral streaming if needed\n            if not used_stream:\n                logger.info(\"Hallucination Falling back to Mistral streaming\")\n                async for (\n                    token,\n                    _prompt,\n                ) in detector.llm_manager.generate_answer_mistral_stream(\n                    query=rewritten_question or message.input,\n                    context=context or \"\",\n                    temperature=getattr(message.request_input, \"temperature\", 0.3),\n                    conversation_context=\"\",\n                ):\n                    if not token:\n                        continue\n                    final_answer_chunks.append(str(token))\n                    yield f\"data: {json.dumps({'type':'token','content':str(token)})}\\n\\n\"\n\n            final_latency = time.perf_counter() - t2\n\n            final_answer = \"\".join(final_answer_chunks)\n            total_latency = time.perf_counter() - total_start\n            latencies = {\n                \"detect\": detect_latency,\n                \"rewrite\": rewrite_latency,\n                **(rag_latencies or {}),\n                \"final_answer\": final_latency,\n                \"total\": total_latency,\n            }\n\n            # Persist to message.hallucination\n            try:\n                message.hallucination = {\n                    \"label\": label,\n                    \"reason\": reason,\n                    \"rewritten_question\": rewritten_question,\n                    \"final_answer\": final_answer,\n                    \"latencies\": latencies,\n                    \"top_k_retrieved_docs\": results,\n                    \"retrieved_docs\": retrieved_docs,\n                }\n                await message.save()\n            except Exception:\n                pass\n\n            final_payload = {\n                \"type\": \"final\",\n                \"label\": label,\n                \"reason\": reason,\n                \"rewritten_question\": rewritten_question,\n                \"answer\": final_answer,\n                \"latencies\": latencies,\n                \"top_k_retrieved_docs\": results,\n            }\n            yield f\"data: {json.dumps(final_payload)}\\n\\n\"\n        except Exception as e:\n            # Persist error and stream error event\n            try:\n                existing_metadata = dict(getattr(message, \"metadata\", {}) or {})\n                existing_metadata[\"error\"] = str(e)\n                message.metadata = existing_metadata\n                await message.save()\n            except Exception:\n                pass\n            yield f\"data: {json.dumps({'type':'error','message':str(e)})}\\n\\n\"\n\n    response = StreamingResponse(_generator(), media_type=\"text/event-stream\")\n    response.headers[\"Cache-Control\"] = \"no-cache\"\n    response.headers[\"Connection\"] = \"keep-alive\"\n    response.headers[\"X-Accel-Buffering\"] = \"no\"\n    return response\n</code></pre>"},{"location":"routers-user/","title":"User","text":""},{"location":"routers-user/#routers.user","title":"<code>user</code>","text":""},{"location":"routers-user/#routers.user.me","title":"<code>me(user: User = Depends(get_current_user)) -&gt; User</code>  <code>async</code>","text":"<p>Return the authenticated user's profile.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>User</code> <p>Current user.</p> Source code in <code>src/routers/user.py</code> <pre><code>@router.get(\"/me\", response_model=User)\nasync def me(user: User = Depends(get_current_user)) -&gt; User:\n    \"\"\"\n    Return the authenticated user's profile.\n\n    Args:\n        user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Current user.\n    \"\"\"\n    return user\n</code></pre>"},{"location":"routers-user/#routers.user.update_user","title":"<code>update_user(request: UpdateUserRequest, user: User = Depends(get_current_user)) -&gt; User</code>  <code>async</code>","text":"<p>Update the authenticated user's profile.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>UpdateUserRequest</code> <p>New user attributes to set.</p> required <code>user</code> <code>User</code> <p>Authenticated user injected by dependency.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>User</code> <p>Updated user.</p> Source code in <code>src/routers/user.py</code> <pre><code>@router.patch(\"\", response_model=User)\nasync def update_user(\n    request: UpdateUserRequest, user: User = Depends(get_current_user)\n) -&gt; User:\n    \"\"\"\n    Update the authenticated user's profile.\n\n    Args:\n        request (UpdateUserRequest): New user attributes to set.\n        user (User): Authenticated user injected by dependency.\n\n    Returns:\n        Updated user.\n    \"\"\"\n    user.first_name = request.first_name\n    user.last_name = request.last_name\n    await user.save()\n    return user\n</code></pre>"},{"location":"types/","title":"Types","text":""},{"location":"types/#common","title":"Common","text":""},{"location":"types/#pagination","title":"Pagination","text":"<ul> <li>page: int (default 1)</li> <li>limit: int (default 10)</li> </ul>"},{"location":"types/#paginationmetadata","title":"PaginationMetadata","text":"<ul> <li>total_count: int</li> <li>current_page: int</li> <li>total_pages: int</li> <li>has_next: bool</li> </ul>"},{"location":"types/#paginatedresponset","title":"PaginatedResponse[T]","text":"<ul> <li>data: list[T]</li> <li>meta: PaginationMetadata</li> </ul>"},{"location":"types/#auth","title":"Auth","text":""},{"location":"types/#loginrequest","title":"LoginRequest","text":"<ul> <li>email: string (email)</li> <li>password: string</li> </ul>"},{"location":"types/#loginresponse","title":"LoginResponse","text":"<ul> <li>access_token: string</li> <li>refresh_token: string</li> </ul>"},{"location":"types/#refreshrequest","title":"RefreshRequest","text":"<ul> <li>refresh_token: string</li> </ul>"},{"location":"types/#refreshresponse","title":"RefreshResponse","text":"<ul> <li>access_token: string</li> </ul>"},{"location":"types/#signuprequest","title":"SignupRequest","text":"<ul> <li>email: string (email)</li> <li>password: string</li> <li>first_name: string | null</li> <li>last_name: string | null</li> </ul>"},{"location":"types/#signupresponse","title":"SignupResponse","text":"<ul> <li>id: string</li> <li>email: string (email)</li> <li>first_name: string | null</li> <li>last_name: string | null</li> </ul>"},{"location":"types/#resendactivationrequest","title":"ResendActivationRequest","text":"<ul> <li>email: string</li> </ul>"},{"location":"types/#verifyrequest","title":"VerifyRequest","text":"<ul> <li>email: string</li> <li>activation_code: string</li> </ul>"},{"location":"types/#user","title":"User","text":""},{"location":"types/#updateuserrequest","title":"UpdateUserRequest","text":"<ul> <li>first_name: string</li> <li>last_name: string</li> </ul>"},{"location":"types/#user-response-model","title":"User (response model)","text":"<ul> <li>Inherits <code>MongoModel</code> \u2192 includes id: string, timestamp: datetime</li> <li>email: string (email)</li> <li>password_hash: string</li> <li>first_name: string | null</li> <li>last_name: string | null</li> <li>is_active: bool</li> <li>activation_code: string | null</li> </ul>"},{"location":"types/#collections","title":"Collections","text":""},{"location":"types/#collectionrequest","title":"CollectionRequest","text":"<ul> <li>embeddings_model: string</li> <li>name: string</li> <li>description: string</li> </ul>"},{"location":"types/#collectionupdate","title":"CollectionUpdate","text":"<ul> <li>name: string</li> </ul>"},{"location":"types/#collection-response-model","title":"Collection (response model)","text":"<ul> <li>Inherits <code>MongoModel</code> \u2192 includes id: string, timestamp: datetime</li> <li>user_id: string | null</li> <li>name: string</li> <li>description: string | null</li> <li>embeddings_model: string</li> </ul>"},{"location":"types/#documents","title":"Documents","text":""},{"location":"types/#adddocumentrequest","title":"AddDocumentRequest","text":"<ul> <li>embeddings_model: string</li> <li>chunk_size: int</li> <li>chunk_overlap: int</li> <li>metadata_urls: list[string] | null</li> <li>metadata_names: list[string] | null</li> </ul>"},{"location":"types/#updatedocumentrequest","title":"UpdateDocumentRequest","text":"<ul> <li>embeddings_model: string</li> <li>source_name: string</li> <li>new_metadata: dict | null</li> </ul>"},{"location":"types/#document-response-model","title":"Document (response model)","text":"<ul> <li>Inherits <code>MongoModel</code> \u2192 includes id: string, timestamp: datetime</li> <li>user_id: string</li> <li>collection_id: string</li> <li>name: string</li> <li>filename: string | null</li> <li>file_type: string | null</li> <li>source_url: string | null</li> <li>chunk_count: int | null</li> <li>file_size: int | null</li> <li>vector_ids: list[string] | null</li> </ul>"},{"location":"types/#conversations","title":"Conversations","text":""},{"location":"types/#conversationcreate","title":"ConversationCreate","text":"<ul> <li>name: string</li> </ul>"},{"location":"types/#conversationnameupdate","title":"ConversationNameUpdate","text":"<ul> <li>name: string</li> </ul>"},{"location":"types/#conversationdetail-response-model","title":"ConversationDetail (response model)","text":"<ul> <li>id: string</li> <li>user_id: string</li> <li>name: string</li> <li>timestamp: datetime</li> <li>messages: list[Message]</li> </ul>"},{"location":"types/#conversation-response-model","title":"Conversation (response model)","text":"<ul> <li>Inherits <code>MongoModel</code> \u2192 includes id: string, timestamp: datetime</li> <li>user_id: string</li> <li>name: string</li> <li>summary: string | null</li> </ul>"},{"location":"types/#messages","title":"Messages","text":""},{"location":"types/#generationrequest","title":"GenerationRequest","text":"<ul> <li>query: string</li> <li>year: list[int] | null</li> <li>filters: dict | null</li> <li>llm_type: string | null (one of 'runpod', 'mistral', 'satcom_small', 'satcom_large')</li> <li>embeddings_model: string</li> <li>k: int</li> <li>temperature: float</li> <li>score_threshold: float</li> <li>max_new_tokens: int</li> <li>public_collections: list[string]</li> <li>Note: server populates private <code>collection_ids</code> and <code>private_collections_map</code>.</li> </ul>"},{"location":"types/#createmessageresponse","title":"CreateMessageResponse","text":"<ul> <li>id: string</li> <li>query: string</li> <li>answer: string</li> <li>documents: list[DocumentReference]</li> <li>use_rag: bool</li> <li>conversation_id: string</li> <li>loop_result: LoopResult | null</li> <li>metadata: ResponseMetadata</li> </ul>"},{"location":"types/#documentreference","title":"DocumentReference","text":"<ul> <li>id: string | null</li> <li>version: int | null</li> <li>score: float | null</li> <li>reranking_score: float | null</li> <li>collection_name: string | null</li> <li>payload: dict</li> <li>text: string</li> <li>metadata: dict</li> </ul>"},{"location":"types/#latencies","title":"Latencies","text":"<ul> <li>guardrail_latency: float | null</li> <li>rag_decision_latency: float | null</li> <li>query_embedding_latency: float | null</li> <li>qdrant_retrieval_latency: float | null</li> <li>mcp_retrieval_latency: float | null</li> <li>reranking_latency: float | null</li> <li>base_generation_latency: float | null</li> <li>fallback_latency: float | null</li> <li>hallucination_latency: HallucinationLatencies | null</li> <li>total_latency: float | null</li> </ul>"},{"location":"types/#hallucinationlatencies","title":"HallucinationLatencies","text":"<ul> <li>detection_latency: float | null</li> <li>span_reprompting_latency: float | null</li> <li>query_rewriting_latency: float | null</li> <li>regeneration_latency: float | null</li> <li>overall_latency: float | null</li> </ul>"},{"location":"types/#responsemetadata","title":"ResponseMetadata","text":"<ul> <li>latencies: Latencies</li> </ul>"},{"location":"types/#loopresult","title":"LoopResult","text":"<ul> <li>final_answer: string | null</li> <li>generation_response: dict | null</li> <li>hallucination_response: dict | null</li> <li>rewrite_response: dict | null</li> <li>reflected_response: dict | null</li> <li>ranked_output: dict | null</li> <li>docs: string | null</li> </ul>"},{"location":"types/#hallucinationdetectresponse","title":"HallucinationDetectResponse","text":"<ul> <li>label: int</li> <li>reason: string</li> </ul>"},{"location":"types/#sourcelogsrequest","title":"SourceLogsRequest","text":"<ul> <li>source_id: string | null</li> <li>source_url: string | null</li> <li>source_title: string | null</li> <li>source_collection_name: string | null</li> </ul>"},{"location":"types/#tools","title":"Tools","text":""},{"location":"types/#toolconfigrequest","title":"ToolConfigRequest","text":"<ul> <li>url: string | null</li> <li>transport: \"streamable_http\" | \"stdio\" | null</li> <li>headers: dict[str, str] | null</li> <li>command: string | null</li> <li>args: list[string] | null</li> <li>env: dict[str, str] | null</li> </ul>"},{"location":"types/#toolrequest","title":"ToolRequest","text":"<ul> <li>name: string</li> <li>provider: string | null</li> <li>description: string | null</li> <li>type: string (default \"mcp\")</li> <li>enabled: bool</li> <li>environment: list[string] | null</li> <li>config: ToolConfigRequest</li> </ul>"},{"location":"types/#toolupdate","title":"ToolUpdate","text":"<ul> <li>Partial fields mirroring <code>ToolRequest</code>; all optional.</li> </ul>"},{"location":"types/#tool-response-model","title":"Tool (response model)","text":"<ul> <li>Inherits <code>MongoModel</code> \u2192 includes id: string, timestamp: datetime</li> <li>user_id: string | null</li> <li>name: string</li> <li>provider: string | null</li> <li>description: string | null</li> <li>type: enum (\"mcp\")</li> <li>enabled: bool</li> <li>environment: list[string] | null</li> <li>config: ToolConfig</li> <li>created_at: datetime</li> <li>updated_at: datetime</li> <li>deleted_at: datetime | null</li> </ul>"},{"location":"types/#toolconfig-response-model","title":"ToolConfig (response model)","text":"<ul> <li>url: string | null</li> <li>transport: enum (\"streamable_http\" | \"stdio\") | null</li> <li>headers: dict[str, str] | null</li> <li>command: string | null</li> <li>args: list[string] | null</li> <li>env: dict[str, str] | null</li> </ul>"},{"location":"types/#forgot-password","title":"Forgot Password","text":""},{"location":"types/#forgotpasswordrequest","title":"ForgotPasswordRequest","text":"<ul> <li>email: string (email)</li> </ul>"},{"location":"types/#forgotpasswordconfirmation","title":"ForgotPasswordConfirmation","text":"<ul> <li>new_password: string</li> <li>confirm_password: string</li> <li>code: string</li> </ul>"}]}